h1. Guide to Things

{{toc}}

This is the central hub for information sharing. Goals of this
document:

* Simply saying ``what is there'' and who could be asked to get further information.

* The page should directly link to technical infos, be searchable, and be a kind of guide to beginners on where to start reading and find information.



h1. How to setup accounts, Ubuntu packages, external libs

* You need at least an account on achtauge and redmine
  (https://maserati.mi.fu-berlin.de/redmine/projects/mlr)

* On Debian/Ubuntu, the following packages should be installed:
<pre>
liblapack-dev
freeglut3-dev
libqhull-dev
libf2c2-dev
libann-dev
libplib-dev
gnuplot
meld
</pre>

* For a full installation (e.g., interaction with the robot) one also
  needs the external libs
<pre>
cuda@
cudaSDK@
opencv-2.1@
ntcan@
schunkLWA@
schunkSDH-11-05-11@ 
</pre>
These are symbolic-linked in the git/share/extern directory. Call the
  ./LINK <your-path> script to generate the relevant links.

* TODO: In the future all external libs should be handled like
  ODE_0.11: minimal GET/BUILD script and .gitignore

* Try 'make' in the git/share directory. If problems occur, try to
comment the following lines in the src/MT/Makefile:
<pre>
#FREEGLUT = 1
#ANN = 1
#LAPACK = 1
</pre>
This reduces functionality of the
code, but should at least compile.

* Generally, the git/share/make-config allows to set compile options for all
projects, the local Makefiles trigger these options by defining
'ANN=1' or alike.

* Try test/array/x.exe




h2. Guide to the robot hardware (Marc & Stanio)

* how to startup the system and test it

h2. Guide to BiROS (parallel processing architecture) (Marc)


h3. Where to start learning

* The BiROS doxygen

h3. Status: the basic mechanisms in process.h are robust and reliable. 

h2. Guide to ORS (robot simulation data structures) (Marc)

There are numerous robot simulation environments out there. Why introduce a new one? Well, actually the aim of ORS is not to develop a new full robot simulation environment. Instead, it aims to provide basic data structures that help to link to existing external libraries and algorithms together. In that way we can flexibly provide a simulation environment with different features enabled by linking to external libraries -- but always with the same basic interface as provided by the ORS data structures.

The data structures are really simple and basic (see ors.h): Vector, Quaternion, Frame, Joint, Body, kinematic Graph -- that's basically it.

Beyond the data structures, ORS also implements two functional things:

* The jacobian (but that's trivial, given the kinematic graph)

* So-called TaskVariables: These are very useful for designing motion
   control contraints (more precisely: cost terms for motion rate
   control or stochastic optimal control). The typical 'endeffector
   position' is only one type of task variable -- I've implemented
   many more (inclluding their Jacobians) which capture relative
   positioning, orientations, alignments, angles, between arbitrary
   frames of the kinematic graph; capturing collision costs, joint
   limit avoidance costs, etc etc. In practice, playing with task
   variables is often the core in designing elegant motions.

ORS can currently link to the following external libraries:


* SWIFT++ for collision (and proximity) detection. (Note: there is
   hardly any alternative out there to do proper proximity(!)
   detection. Bullet, ODE, SOLID, etc don't)

(INSERT LIST OF ALTERNATIVE LIBS)

* ODE for simple dynamic simulation including collision behavior
   (SWIFT++ only detects collisions, but doesn't simulate their
   effects)

* OpenGL for display

* blender (this is a bit outdated -- but I once wrote a python script
   to export/import blender geometries to ORS data structures)

Perhaps on the wishlist for ORS communication:

* OpenRAVE /  OpenGRASP

* IBDS (perhaps much better dynamic simulation than ODE)

* daVinci, bullet, OpenTissue

* Yuval Tassas CapSim (new methods for EXACT contact simulation)


h3. Where to start learning about ORS

# Robot lecture: the basic lecture on 3D geometry (to learn about my
conventions) and perhaps the lecture which introduces task variables
(and their Jacobians)

# Have a look at ALL ors_* test projects in the git repository --
they're really basic. Understand them all. The ``ors_editor'' is useful to
edit the ors-file describing geometries. Play with the test.ors file
while watching the effect in the window.

# The ors doxygen.



h2. Guide to SOC & AICO (Stochastic Optimal Control and motion
   planning routines) (Marc)



h2. Guide to the Array class (the data structure most used throughout
   for vectors, matricies, tensors, lists, graphs, etc)

This is a standard Array lib -- just like many others. (It actually
evolved from a lib started in Bochum, 15 years ago...) The main design
goals are: 

# compatibility with typical mathematical notation when coding
equations (That's in fact most important: It is curcial for us to be
able to code as directly as possible equations we've derived on
paper!)

# compatibility with Matlab/Octave conventions (mostly...).

# full transparacy and minimalism (for easier debugging),

# Many features: unlimited rank tensors, fast memory handling, links
(by default) to LAPACK (@@is just as fast as any other
optimized matrix library), lists -- and everything implemented by only
a SINGLE basic class, not a whole lib of classes.

h3. Important conventions:

* In all my code, a ``list'' is an array of pointers. Why? Years back
   I've implemented double linked lists (O(1) complexity for
   insertion/deletion) as was typically taught (back then) -- but in
   practise that's total nonsense. Insertion/deletion in a pointer
   array is also O(1). And array of point is so so much simpler and
   easier to debug.

   Convention: A ``ThingList'' is a typedef MT::Array<Thing*> !



* Equally for graphs: A ``graph'' is a list of edges and a list of
   nodes! (What else?!) I've implemented basic graph template
   routines. They assume that the node type contains a list of
   in-edges, and a list of out-edges, and the edge type contains a
   pointer to the from-node and a pointer to the to-node.


h3. Where to start learning

# Directly start looking at the 'array' test in the git
repository. Just by reading though all examples I think one learns
most.

# The array doxygen.

# The class has more features (functions) than one might think: I've
seem many students reimplementing routines that are actually already
there -- frankly I don't know how to avoid that.

h3. Future changes:

* Intead of having explisit listX routines (for insertion, deletion,
   sort, etc) there will be a 'listMode' flag in the array class,
   indicating that this array is to be treated as a list of pointers.



h2. Guide to optimization methods (Marc)

There are quite a bit of generic optimization methods implemented --
but not well documented/organized yet:

* Rprop (best gradient descent method)

* GaussNewton

* CMA

* Some Genetic \& Evolutionary Algorithms (e.g., similar to CMA)

Ask Marc.



h2. Guide to inference and Machine Learning methods (Marc)

We have probabilistic inference code (infer lib) and also basic
Machine Learning methods (as introduced in the ML lecture). Ask Marc.

* Gaussian Processes

* ridge regression, logistic regression, etc

* MDPs, POMDPs




h2. Guide to Computer Vision methods (Marc)

LINK to my notes on the CV system


h2. Guide to Robotics algorithms (Nikolay & Marc)

* RRTs

* Trajectory Prediction

* etc



h2. Guide to the relational RL software (Tobias)

h2. Guide to coding utilities

* String class

* Parameters read from cmd line or config file

* plotting in opengl & gnuplot

* opengl using freeglut, fltk or qt


h2. HowTos

What you require

* account on achtauge for working with the robot

* git workflow

<pre>
git clone ssh://<achtauge-user>@achtauge.imp.fu-berlin.de/mnt/data/git/share mlr
git config --global diff.external meld

git status
git diff
git add|mv|rm|... <files>
git commit -am 'message'  (or --all --message 'message')
git pull --all
git push --all

git branch -a
git remote show achtauge
git checkout <branch>
git branch <new-branch>
git branch --track <new-branch> <remote-branch>
git merge <other-branch>

.gitignore
git update-index --assume-unchanged <files>
</pre>

* svn workflow

<pre>
svn co --username=<YOUR ZEDAT LOGIN> --password=<YOUR ZEDAT PW> https://svn.imp.fu-berlin.de/mlr
svn add|del|mv <files>
svn up
svn commit -m 'message'
</pre>

* LaTeX things

h2. Installing software

h3. Ubuntu stuff



h2. 

* getting things done projects (I think they should move to this wiki
   (hwo handle LaTeX?)

